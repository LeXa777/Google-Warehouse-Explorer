/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath"
 * exception as provided by Sun in the License file that accompanied
 * this code.
 */
package org.jdesktop.wonderland.modules.marbleous.client.jme;

import org.jdesktop.wonderland.modules.marbleous.common.TCBKeyFrame;
import com.jme.math.Matrix4f;
import com.jme.math.Quaternion;
import com.jme.math.Vector3f;

/**
 * RotPosScaleTCBSplinePath behavior.  This class defines a
 * behavior that varies the rotational, translational, and scale components 
 * of its target TransformGroup by using the Kochanek-Bartels cubic spline 
 * interpolation to interpolate among a series of key frames
 * (using the value generated by the specified Alpha object).  The
 * interpolated position, orientation, and scale are used to generate
 * a transform in the local coordinate system of this interpolator.  
 */

public class RotPosScaleTCBSplinePath extends TCBSplinePath {

    private Matrix4f    rotation    = new Matrix4f();
    private Matrix4f       tMat        = new Matrix4f();
    private Matrix4f       sMat        = new Matrix4f();
    private Quaternion         iQuat       = new Quaternion();     // interpolated quaternion
    private Vector3f       iPos        = new Vector3f();   // interpolated position 
    private Vector3f        iScale      = new Vector3f();    // interpolated scale

    CubicSplineCurve   cubicSplineCurve = new CubicSplineCurve();
    CubicSplineSegment cubicSplineSegments[]; 
    int                numSegments;
    int                currentSegmentIndex;
    CubicSplineSegment currentSegment;

    // non-public, default constructor used by cloneNode
    RotPosScaleTCBSplinePath() {
    }

    /**
     * Constructs a new RotPosScaleTCBSplinePath object that
     * varies the rotation, translation, and scale of the target 
     * TransformGroup's transform.  At least 2 key frames are required for 
     * this interpolator. The first key
     * frame's knot must have a value of 0.0 and the last knot must have a
     * value of 1.0.  An intermediate key frame with index k must have a
     * knot value strictly greater than the knot value of a key frame with
     * index less than k.
     * @param alpha the alpha object for this interpolator
     * @param target the TransformGroup node affected by this interpolator
     * @param axisOfTransform the transform that specifies the local
     * coordinate system in which this interpolator operates.
     * @param keys an array of key frames that defien the motion path 
     */
    public RotPosScaleTCBSplinePath(Matrix4f axisOfTransform,
						TCBKeyFrame keys[]) {
	super(axisOfTransform, keys);
        // Create a spline curve using the derived key frames
        cubicSplineCurve = new CubicSplineCurve(this.keyFrames); 
        numSegments = cubicSplineCurve.numSegments;

    }

    public RotPosScaleTCBSplinePath(TCBKeyFrame keys[]) {
	super(keys);
        // Create a spline curve using the derived key frames
        cubicSplineCurve = new CubicSplineCurve(this.keyFrames);
        numSegments = cubicSplineCurve.numSegments;

    }
    /**
     * Computes the new transform for this interpolator for a given
     * alpha value.
     *
     * @param alphaValue alpha value between 0.0 and 1.0
     * @param transform object that receives the computed transform for
     * the specified alpha value
     *
     * @since Java 3D 1.3
     */
    public void computeTransform(float alphaValue, Matrix4f transform) {
        transform.loadIdentity();

	// compute the current value of u from alpha and the 
	// determine lower and upper knot points
	computePathInterpolation(alphaValue);

	// Determine the segment within which we will be interpolating
	currentSegmentIndex = this.lowerKnot - 1;
    
	// if we are at the start of the curve 
	if (currentSegmentIndex == 0 && currentU == 0f) {

	    iQuat.set(keyFrames[1].quat);
	    iPos.set(keyFrames[1].position);
	    iScale.set(keyFrames[1].scale);

	    // if we are at the end of the curve 
	} else if (currentSegmentIndex == (numSegments-1) && 
		   currentU == 1.0) {

	    iQuat.set(keyFrames[upperKnot].quat);
	    iPos.set(keyFrames[upperKnot].position);
	    iScale.set(keyFrames[upperKnot].scale);

	    // if we are somewhere in between the curve
	} else {

	    // Get a reference to the current spline segment i.e. the
	    // one bounded by lowerKnot and upperKnot 
	    currentSegment 
		= cubicSplineCurve.getSegment(currentSegmentIndex);

	    // interpolate quaternions 
	    currentSegment.getInterpolatedQuaternion(currentU,iQuat);

	    // interpolate position
	    currentSegment.getInterpolatedPositionVector(currentU,iPos); 

	    // interpolate position
	    currentSegment.getInterpolatedScale(currentU,iScale);

	}

	// Alway normalize the quaternion
	iQuat.normalize();	    
        iQuat.toRotationMatrix(tMat);

	// Set the translation components.
	tMat.m03 = iPos.x;
	tMat.m13 = iPos.y;
	tMat.m23 = iPos.z;
	rotation.set(tMat);
    
	// construct a Transform3D from:  axis * rotation * axisInverse 
//	transform.multLocal(axis);
        transform.multLocal(rotation);
	transform.scale(new Vector3f(iScale));
//	transform.multLocal(axisInverse);
	   
    }
}
