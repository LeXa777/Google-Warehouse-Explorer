/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath"
 * exception as provided by Sun in the License file that accompanied
 * this code.
 */

package org.jdesktop.wonderland.modules.pdfspreader.client.jme.cell;

import com.jme.bounding.BoundingBox;
import com.jme.image.Texture;
import com.jme.image.Texture.MagnificationFilter;
import com.jme.image.Texture.MinificationFilter;
import com.jme.math.Quaternion;
import com.jme.math.Vector3f;
import com.jme.renderer.ColorRGBA;
import com.jme.scene.Node;
import com.jme.scene.Spatial;
import com.jme.scene.TriMesh;
import com.jme.scene.shape.Box;
import com.jme.scene.state.MaterialState;
import com.jme.scene.state.RenderState;
import com.jme.scene.state.TextureState;
import com.jme.util.TextureManager;
import com.sun.pdfview.PDFFile;
import com.sun.pdfview.PDFPage;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.ByteBuffer;
import java.util.Date;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;
import org.jdesktop.mtgame.Entity;
import org.jdesktop.mtgame.RenderManager;
import org.jdesktop.mtgame.RenderUpdater;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.asset.AssetUtils;
import org.jdesktop.wonderland.client.jme.ClientContextJME;
import org.jdesktop.wonderland.client.jme.cellrenderer.BasicRenderer;
import org.jdesktop.wonderland.common.cell.CellStatus;
import org.jdesktop.wonderland.modules.pdfspreader.client.PDFSpreaderCell;
import org.jdesktop.wonderland.modules.pdfspreader.common.PDFSpreaderCellChangeMessage;
import org.jdesktop.wonderland.modules.pdfspreader.common.PDFSpreaderCellChangeMessage.LayoutType;
import org.jdesktop.wonderland.modules.pdfspreader.common.PDFSpreaderCellChangeMessage.MessageType;

public class PDFSpreaderCellRenderer extends BasicRenderer {
    private Node node = null;

    private PDFSpreaderCell pdfCell;

    private static final Logger logger =
            Logger.getLogger(PDFSpreaderCellRenderer.class.getName());

    // The PDF object generated by the PDF parsing library. 
    private PDFFile pdf;

    // Keeps track of the slide objects so we can
    // move them around in response to HUD events.
    private List<Spatial> slides = new Vector<Spatial>();

    // Controls the relationship between the size of the rendered texture
    // (as generated from the PDF library) and the object in world.
    // Making this value bigger makes slides appear bigger in world.
    public static final float SLIDE_SIZE_FACTOR = 0.00125F;

    public PDFSpreaderCellRenderer(Cell cell) {
        super(cell);
        this.pdfCell = (PDFSpreaderCell) cell;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setStatus(CellStatus status, boolean increasing) {
        super.setStatus(status, increasing);

        // If we are becoming active, turn off the lighting
        if (status == CellStatus.ACTIVE && increasing == true) {
            setLightingEnabled(false);
        }
    }

    @Override
    protected Node createSceneGraph(Entity entity) {

        // Make just one empty node that stuff will get attached to later. 
        node = new Node();

        // Kick off a thread that will manage the loading asynchronously. 
        Thread t = new PageLoadingThread(node);
        t.start();

        node.setModelBound(new BoundingBox());
        node.updateModelBound();

        node.setLocalRotation(new Quaternion().fromAngleNormalAxis((float) (Math.PI / 2), new Vector3f(0,1,0)));
        node.setLocalScale(pdfCell.getScale());

        node.setModelBound(new BoundingBox());
        return node;
}

    /**
     * Triggers a re-layout process based on the latest values from the cell.
     *
     * Executes asynchronously in the main rendering thread. 
     */
    public void updateLayout() {

        ClientContextJME.getWorldManager().addRenderUpdater(new RenderUpdater() {

            public void update(Object arg) {
                // update scale of root node
                node.setLocalScale(pdfCell.getScale());

                // redo layout.
                int i = 0;
                for (Spatial s : slides) {
                    setSpatialPosition(s, i);
                    i++;
                }
            }},null);
}

    /**
     * Get an image of a specific page
     *
     * Taken from PDFViewerApp.java, with some modifications.
     *
     * @param p the page number
     * @return the image of the specified page
     */
    public BufferedImage getPageImage(int p) {
        BufferedImage image = null;

        PDFPage currentPage;
        try {
            if (isValidPage(p)) {
                currentPage = pdf.getPage(p, true);

                // Set the size at which we want to render the image texture.
                // Doing it *2 right now beacuse that renders at double resolution,
                // which looks better when you zoom in.
                double ph = currentPage.getWidth()*2;
                double pw = currentPage.getHeight()*2;

                Image img = pdf.getPage(p).getImage((int)pw, (int)ph, null, null, true, true);

                logger.info("img from pdfpage: " + img);

                if (img != null) {
                    // convert the page image into a buffered image
                    image = new BufferedImage((int)pw, (int)ph, BufferedImage.TYPE_INT_ARGB);
                    Graphics2D g2 = image.createGraphics();
                    g2.drawImage(img, 0, 0, (int)pw, (int)ph, null);
                } else {
                    logger.warning("PDF viewer failed to get image for page: " + p);
                }
            }
        } catch (Exception e) {
            logger.severe("PDF viewer failed to get page image: " + e);
        }

        return image;
    }

    /**
     * Get the validity of the specified page in the currently open document
     * @return true if the page is within the range of pages of the current
     * document, false otherwise
     */
    public boolean isValidPage(int p) {
        return ((pdf != null) && (p > 0) && (p <= pdf.getNumPages()));
    }


    /**
     * Get the PDF document data from a URL
     *
     * (Taken verbatim from PDFViewerApp.java)
     *
     * @param docURL the URL of the PDF document to open
     * @return the PDF document data
     */
    public ByteBuffer getDocumentData(String docURL) throws IOException {
        ByteBuffer buf = null;

        if (docURL != null) {
            // connect to the URL
            URL url = AssetUtils.getAssetURL(docURL, cell);
            URLConnection conn = url.openConnection();
            conn.connect();

            // create a buffer to load the document into
            int docSize = conn.getContentLength();

            // Just try reading from it, first.

            // create a buffered stream for reading the document
            DataInputStream is = new DataInputStream(new BufferedInputStream(conn.getInputStream()));

            Vector<Byte> bytesVec = new Vector<Byte>();
            byte b;
            int numBytes = 0;
            while(true) {
                try {
                    b = is.readByte();

                    bytesVec.add(b);
                    numBytes++;
                } catch (EOFException e) {
                    break;
                } catch (Exception e) {
                    logger.warning("Error reading PDF in loop: " + e.getMessage());
                    e.printStackTrace();
                    break;
                }

            }

            byte[] bytes = new byte[bytesVec.size()];
            int i = 0;
            for(Byte curB : bytesVec) {
                bytes[i] = bytesVec.get(i);
                i++;
            }

            buf = ByteBuffer.wrap((byte[]) bytes, 0, ((byte[]) bytes).length);
        }

        logger.fine("returning buffer: " + buf + " with length: " + buf.array().length);

        return buf;
    }

    private class PageLoadingThread extends Thread {

        private Node node;

        public PageLoadingThread(Node n) {
            node = n;
        }

        public void run() {

            logger.fine("Creating scene graph for entity: " + entity);

            String name = cell.getCellID().toString();

            String pdfURI = ((PDFSpreaderCell) cell).getSourceURI();
            try {
                Date then = new Date();
                pdf = new PDFFile(getDocumentData(pdfURI));
                Date now = new Date();

                logger.fine("PDF loaded in: " + (now.getTime() - then.getTime()) + "ms");
            } catch (Exception e) {
                logger.warning("PDF failed to load: " + e.getMessage());
                e.printStackTrace();
            }

            float maxHeight = 0.0f;
            float maxWidth = 0.0f;

            // centered around 0,0, calculate starting position.            
            for (int i = 1; i <= pdf.getNumPages(); i++) {

                // logger.warning("currentCenter: " + currentCenter + " (page " + i + ")");
                // for each page, we need to:
                //   1. make a new Box
                //   2. get the image for this page and make it into a texture
                //   3. apply the texture to the box
                //   4. move the position pointer for the next box

                BufferedImage pageTexture = getPageImage(i);
                
                // Dispatch the JME specific stuff to a thread that we can run inside
                // the RenderingThread.
                ClientContextJME.getWorldManager().addRenderUpdater((RenderUpdater)new NewSlideUpdater(node, pageTexture, i), null);

                if(pageTexture.getHeight()*SLIDE_SIZE_FACTOR>maxHeight)
                    maxHeight = pageTexture.getHeight()*SLIDE_SIZE_FACTOR;

                if(pageTexture.getWidth()*SLIDE_SIZE_FACTOR>maxWidth)
                    maxWidth = pageTexture.getWidth()*SLIDE_SIZE_FACTOR;
            }

            setSlideDimensions(maxHeight, maxWidth);
        }
    }

    private void newSlide(Spatial s) {
        slides.add(s);
    }

    /**
     * Given a layout type, a node, and an index, move/rotate the node
     * so it's in the right place. This parameterised abstraction makes it
     * easier to update the postions of things to different layout types on
     * the fly.
     * 
     * @param layout
     * @param n
     * @param i
     */
    private void setSpatialPosition(Spatial s, int i) {
        Vector3f pos = null;;
        Quaternion rot = null;

        float curAngle;
        LayoutType layout = this.pdfCell.getLayout();
        switch(layout) {
            case CIRCLE:
                curAngle = (float) (i * (2*Math.PI / this.pdf.getNumPages()));
                rot = new Quaternion().fromAngleNormalAxis((float) (curAngle + Math.PI / 2), new Vector3f(0, 1, 0));
                pos = new Vector3f((float)(pdfCell.getSpacing()*Math.sin(curAngle)), 0.0f, (float)(pdfCell.getSpacing()*Math.cos(curAngle)));
                break;

            case SEMICIRCLE:
                int n = this.pdf.getNumPages() - i;
                curAngle = (float) (n * (Math.PI / this.pdf.getNumPages()));
                pos = new Vector3f((float)(pdfCell.getSpacing()*Math.sin(curAngle)), 0.0f, (float)(pdfCell.getSpacing()*Math.cos(curAngle)));
                rot = new Quaternion().fromAngleNormalAxis((float) (curAngle + Math.PI / 2), new Vector3f(0, 1, 0));
                break;
                
            case LINEAR:
                // i->1 because pages is 1->n, not 0->(n-1)
                // the other negative bit recenters the line around the middle
                // of the set of slides, not the start point.
                pos = new Vector3f(0, 0, (pdfCell.getSpacing() * (i-1) + (pdfCell.getSpacing()*((pdf.getNumPages()-1)/2.0f)*-1)));
                rot = new Quaternion();
                break;

            default:
                break;
        }

        logger.finer("(" + i + ") pos: " + s.getLocalTranslation() + " -> " + pos);
        s.setLocalTranslation(pos);
        s.setLocalRotation(rot);
        ClientContextJME.getWorldManager().addToUpdateList(s);
    }

    protected void setSlideDimensions(float width, float height) {
        

        // Once we know the first slide's dimensoin, trigger a message that
        // informs the server what it is (as well as the num pages)
        // This data will allow the server to figure out how to place
        // the platform.

        // Trigger a message to the server with the number of pages.
        PDFSpreaderCellChangeMessage msg = new PDFSpreaderCellChangeMessage(MessageType.DOCUMENT);
        msg.setNumPages(pdf.getNumPages());

        // Thought a little bit here about how scaling will work. If you scale up the
        // PDFCell, should that scale transfer to the PresentationCell? Probably.
        msg.setSlideWidth(width);

        pdfCell.sendCellMessage(msg);
    }

    private class NewSlideUpdater implements RenderUpdater {

        private Node parent;
        private BufferedImage page;
        private int index;

        public NewSlideUpdater(Node p, BufferedImage texture, int i) {
            parent = p;
            page = texture;
            index = i;
        }

        public void update(Object arg0) {
                Texture texture = TextureManager.loadTexture(page, MinificationFilter.BilinearNoMipMaps, MagnificationFilter.Bilinear, true);

                texture.setWrap(Texture.WrapMode.BorderClamp);
                texture.setTranslation(new Vector3f());

                // Figure out what the size of the texture is, scale it down to something
                // reasonable.
                float width = texture.getImage().getWidth() * SLIDE_SIZE_FACTOR;
                float height = texture.getImage().getHeight() * SLIDE_SIZE_FACTOR;

                TriMesh currentSlide = new Box(cell.getCellID().toString() + "_" + index, new Vector3f(), 0.1f, width, height);
                node.attachChild(currentSlide);
                logger.finer("Just attached slide to node, with (" + width + "," + height + ")");

                RenderManager rm = ClientContextJME.getWorldManager().getRenderManager();

                TextureState ts = (TextureState) rm.createRendererState(RenderState.StateType.Texture);
                ts.setTexture(texture);
                ts.setEnabled(true);

                MaterialState ms = (MaterialState) rm.createRendererState(RenderState.StateType.Material);
                ms.setDiffuse(ColorRGBA.white);
                ms.setColorMaterial(MaterialState.ColorMaterial.Diffuse);
                currentSlide.setRenderState(ms);

                currentSlide.setRenderState(ts);
                currentSlide.setSolidColor(ColorRGBA.white);

                setSpatialPosition(currentSlide, index);

                currentSlide.setModelBound(new BoundingBox());
                currentSlide.updateModelBound();


                ClientContextJME.getWorldManager().addToUpdateList(currentSlide);

                // This is not the right place to be doing this - it really only
                // needs to get done after the last slide. But it's easier than
                // making sure we run an update only at the end, and it keeps
                // the bounds constantly up to date as slides get added.
                node.setLocalScale(pdfCell.getScale());
                node.updateModelBound();
                node.updateRenderState();
                
                ClientContextJME.getWorldManager().addToUpdateList(node);

                newSlide(currentSlide);
        }
    }
}