/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath"
 * exception as provided by Sun in the License file that accompanied
 * this code.
 */

package org.jdesktop.wonderland.modules.metadata.client;

import java.awt.GridBagLayout;
import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JPanel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import org.jdesktop.wonderland.client.cell.properties.CellPropertiesEditor;
import org.jdesktop.wonderland.client.cell.properties.annotation.PropertiesFactory;
import org.jdesktop.wonderland.client.cell.properties.spi.PropertiesFactorySPI;
import org.jdesktop.wonderland.common.cell.state.CellServerState;
import org.jdesktop.wonderland.modules.metadata.common.MetadataComponentServerState;
import org.jdesktop.wonderland.modules.metadata.common.Metadata;

/**
 * Provides an editing pane for Metadata in the cell properties editor. 
 * @author mabonner
 */
@PropertiesFactory(MetadataComponentServerState.class)
public class MetadataComponentProperties extends JPanel implements PropertiesFactorySPI {
  private CellPropertiesEditor editor = null;
  private static Logger logger = Logger.getLogger(MetadataComponentProperties.class.getName());

  /**
   * used to store the metadata viewed by the properties pane (in tabs)
   *
   * set in open, used in restore
   */
  Collection<Metadata> originalMetadata = new ArrayList<Metadata>();

  // TODO could not add MetadataTypesTable to NetBeans GUI Builder
  // workaround: use customize code to make basicTabs instantiated as
  // a MTT. Cast basicTabs to an MTT and use the tabs reference instead.
  private MetadataTypesTable tabs;

    /** Creates new form MetadataComponentProperties */
    public MetadataComponentProperties() {
        // this panel is dynamically populated
        super(new GridBagLayout());
        initComponents();

        // work-around for NetBeans GUI builder
        // see comment where tabs is declared
        tabs = (MetadataTypesTable) basicTabs;

        // add listeners
        tabs.registerListSelectionListener(new RemoveButtonSelectionListener());
        tabs.registerTableModelListener(new TableDirtyListener());
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jLabel1 = new javax.swing.JLabel();
    controls = new javax.swing.JPanel();
    addButton = new javax.swing.JButton();
    removeButton = new javax.swing.JButton();
    basicTabs = new MetadataTypesTable();

    jLabel1.setText("Metadata");

    controls.setBackground(new java.awt.Color(204, 204, 255));

    addButton.setText("+");
    addButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        addButtonActionPerformed(evt);
      }
    });

    removeButton.setText("-");
    removeButton.setEnabled(false);
    removeButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        removeButtonActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout controlsLayout = new javax.swing.GroupLayout(controls);
    controls.setLayout(controlsLayout);
    controlsLayout.setHorizontalGroup(
      controlsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(controlsLayout.createSequentialGroup()
        .addContainerGap()
        .addGroup(controlsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(addButton)
          .addComponent(removeButton))
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );
    controlsLayout.setVerticalGroup(
      controlsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(controlsLayout.createSequentialGroup()
        .addContainerGap()
        .addComponent(addButton)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(removeButton)
        .addContainerGap(30, Short.MAX_VALUE))
    );

    basicTabs.setPreferredSize(new java.awt.Dimension(32767, 32767));

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addGap(36, 36, 36)
            .addComponent(jLabel1))
          .addGroup(layout.createSequentialGroup()
            .addContainerGap()
            .addComponent(basicTabs, javax.swing.GroupLayout.DEFAULT_SIZE, 480, Short.MAX_VALUE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(controls, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addGap(18, 18, 18)))
        .addContainerGap())
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(jLabel1)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(basicTabs, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE))
      .addGroup(layout.createSequentialGroup()
        .addGap(40, 40, 40)
        .addComponent(controls, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addContainerGap(211, Short.MAX_VALUE))
    );
  }// </editor-fold>//GEN-END:initComponents

    private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeButtonActionPerformed
      tabs.removeCurrentlySelectedRow();
}//GEN-LAST:event_removeButtonActionPerformed

    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addButtonActionPerformed
      tabs.createNewDefaultMetadataOnCurrentTab();
}//GEN-LAST:event_addButtonActionPerformed


  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton addButton;
  private javax.swing.JTabbedPane basicTabs;
  private javax.swing.JPanel controls;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JButton removeButton;
  // End of variables declaration//GEN-END:variables
  
  public Class getServerCellComponentClass() {
    return MetadataComponentServerState.class;
  }

  public String getDisplayName() {
    return "Cell Metadata Component";
  }

  /**
   * @inheritDoc()
   */
  public void setCellPropertiesEditor(CellPropertiesEditor editor) {
    this.editor = editor;
  }

  /**
   * @inheritDoc()
   */
  public JPanel getPropertiesJPanel() {
    return this;
  }

  /**
   * @inheritDoc()
   */
  public void open() {
    logger.info("[METADATA COMPO PROPERTIES] open!");
    MetadataComponentServerState state = getServerState();
    // currently, this naively clears tabs and repopulates them
    tabs.clearTabs();
    logger.info("size of metadata in open:" + state.getAllMetadata().size());
    tabs.addMetadata(state.getAllMetadata());
    originalMetadata = state.getAllMetadata();
    editor.setPanelDirty(MetadataComponentProperties.class, false);
  }

  
  /**
   * @inheritDoc()
   */
  public void close() {
    // do nothing
  }

  /**
   * @inheritDoc()
   */
  public void restore() {
    logger.info("[METADATA COMPO PROPERTIES] get cell server state!");
    // currently, this naively clears tabs and repopulates them
    tabs.clearTabs();
    tabs.addMetadata(originalMetadata);
    logger.info("size of metadata after restore:" + originalMetadata.size());
  }

  /**
   * @inheritDoc()
   */
  public void apply() {
    logger.info("[METADATA COMPO PROPERTIES] apply!");
    // Figure out whether there already exists a server state for the
    // component.
    MetadataComponentServerState state = getServerState();
      if (state == null) {
          state = new MetadataComponentServerState();
      }

      logger.info("[METADATA COMPO PROPERTIES] previous state count:" + state.getAllMetadata().size() );
      // TODO
      // naively clear this, in the future we could track which metadata
      // objects have been changed and adjust only them
      state.removeAllMetadata();
      // convert models back into ServerState
      logger.info("[METADATA COMPO PROPERTIES] post removeAll state count:" + state.getAllMetadata().size() );
      for(int i = 0; i < tabs.getComponentCount(); i++){
        try {
          for (Metadata m : tabs.getMetadataFromTab(i)) {
            state.addMetadata(m);
          }
        } catch (Exception ex) {
            Logger.getLogger(MetadataComponentProperties.class.getName()).log(Level.SEVERE, null, ex);
        }
      }

      logger.info("[METADATA COMPO PROPERTIES] state to be added count:" + state.getAllMetadata().size() );
      // TODO
      // this overwrites the old serverstate, which could result in needlessly
      // overwriting unchanged metadata elts
      // this is fairly lightweight.. could be improved by tracking what elts
      // (e.g. tabs and rows) were changed, and overwriting only them.
      editor.addToUpdateList(state);
  }

  public MetadataComponentServerState getServerState(){
    logger.info("[METADATA COMPO PROPERTIES] get server state" );
    CellServerState cellServerState = editor.getCellServerState();
    MetadataComponentServerState state = (MetadataComponentServerState)
        cellServerState.getComponentServerState(MetadataComponentServerState.class);
    return state;
  }


  class RemoveButtonSelectionListener implements ListSelectionListener {
        public void valueChanged(ListSelectionEvent e) {
            boolean enabled = false;

            if (!e.getValueIsAdjusting()) {
                enabled = (tabs.getCurrentTable().getSelectedRow() >= 0);
            }

            removeButton.setEnabled(enabled);
        }
    }

  class TableDirtyListener implements TableModelListener {

//    public void tableChanged(TableModelEvent tme) {
//      System.out.println("[METADATA COMPO PROPERTIES] table is dirty");
//        editor.setPanelDirty(MetadataComponentProperties.class, true);
//    }

    public void tableChanged(TableModelEvent tme) {
      System.out.println("[METADATA COMPO PROPERTIES] table is dirty");
      if (editor == null) {
                return;
      }
      editor.setPanelDirty(MetadataComponentProperties.class, true);
    }
  }

}



